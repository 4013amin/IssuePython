<body>
    
    <p>حتماً برای شما هم پیش آمده که در یک پروژه برنامه‌نویسی، با کدی مواجه شوید که پیچیده و سخت‌فهم است. یا شاید خودتان کدی نوشته باشید که بعد از مدتی حتی خودتان هم به سختی می‌توانید آن را تغییر دهید یا گسترش دهید. اینجاست که اصول SOLID به کمک ما می‌آیند!</p>
    
    <p>SOLID مجموعه‌ای از پنج اصل طراحی شی‌گراست که هدفشان ساده‌تر کردن کدنویسی و بهبود ساختار و انعطاف‌پذیری کدهاست. با رعایت این اصول، کدی که می‌نویسیم قابل فهم‌تر، انعطاف‌پذیرتر و قابل توسعه‌تر می‌شود. حالا بیایید به زبانی خیلی ساده هر کدام از این اصول را مرور کنیم:</p>
    
    <h2>1. اصل تک‌مسئولیتی (Single Responsibility Principle - SRP)</h2>
    <p>هر کلاس یا ماژول باید فقط یک کار مشخص انجام دهد و برای همان یک کار تغییر کند. یعنی هر چیزی که می‌نویسیم، باید یک "وظیفه" یا "مسئولیت" مشخص داشته باشد.</p>
    
    <p><strong>به زبان ساده:</strong><br>
    فرض کنید یک کلاس داریم که هم مسئول ذخیره‌سازی اطلاعات کاربر است و هم برای کاربر ایمیل می‌فرستد. اگر ایمیل‌فرستادن یا ذخیره‌سازی نیاز به تغییر داشته باشد، باید کل کلاس را تغییر دهیم. ولی اگر هر کدام از این وظایف در کلاس‌های جداگانه باشند، هر تغییر فقط بر همان بخش تأثیر می‌گذارد.</p>
    
    <h2>2. اصل باز-بسته (Open/Closed Principle - OCP)</h2>
    <p>کدهای ما باید برای توسعه باز باشند ولی برای تغییر بسته. یعنی بتوانیم قابلیت‌های جدیدی به کد اضافه کنیم بدون اینکه نیاز به تغییر کدهای قدیمی داشته باشیم.</p>
    
    <p><strong>به زبان ساده:</strong><br>
    فرض کنید شما یک کلاس دارید که حساب‌های بانکی را مدیریت می‌کند. حالا قرار است نوع جدیدی از حساب بانکی اضافه شود. اگر کد شما طبق اصل OCP نوشته شده باشد، باید بتوانید به راحتی کلاس جدیدی برای حساب جدید اضافه کنید بدون اینکه در کدهای اصلی حساب‌های دیگر تغییری ایجاد کنید.</p>
    
    <h2>3. اصل جایگزینی لیسکوف (Liskov Substitution Principle - LSP)</h2>
    <p>هر کلاسی که از یک کلاس دیگر ارث‌بری می‌کند، باید بتواند به جای کلاس والد استفاده شود، بدون اینکه رفتار نادرستی از خود نشان دهد.</p>
    
    <p><strong>به زبان ساده:</strong><br>
    فرض کنید یک کلاس پایه به نام "حیوان" داریم و از این کلاس برای "پرنده" و "ماهی" ارث‌بری می‌کنیم. اگر کلاس پرنده را به جای حیوان استفاده کنیم، نباید مشکلی به وجود بیاید. یعنی پرنده و ماهی باید همان رفتاری را نشان دهند که از حیوان انتظار داریم.</p>
    
    <h2>4. اصل جداسازی رابط‌ها (Interface Segregation Principle - ISP)</h2>
    <p>بهتر است چندین رابط کوچک داشته باشیم که هر کدام کار خاصی انجام دهند، تا اینکه یک رابط بزرگ و پیچیده داشته باشیم.</p>
    
    <p><strong>به زبان ساده:</strong><br>
    فرض کنید یک رابط داریم که شامل سه متد مختلف است: پرواز کردن، شنا کردن و راه رفتن. حالا اگر موجودی داریم که فقط می‌تواند شنا کند، مجبوریم متدهای پرواز و راه رفتن را هم در آن پیاده‌سازی کنیم. ولی اگر رابط‌های جداگانه‌ای برای هر یک از این رفتارها داشته باشیم، نیازی نیست که موجودات همه متدها را پیاده‌سازی کنند.</p>
    
    <h2>5. اصل وارونگی وابستگی (Dependency Inversion Principle - DIP)</h2>
    <p>ماژول‌های سطح بالا نباید به ماژول‌های سطح پایین وابسته باشند، بلکه هر دو باید به یک رابط وابسته باشند. به عبارتی، کد ما باید به Abstraction (مفاهیم انتزاعی) وابسته باشد، نه به Details (جزئیات پیاده‌سازی).</p>
    
    <p><strong>به زبان ساده:</strong><br>
    فرض کنید کدی نوشته‌اید که به طور مستقیم از یک دیتابیس استفاده می‌کند. حالا اگر بخواهید نوع دیتابیس را تغییر دهید، باید بخش بزرگی از کد را هم تغییر دهید. ولی اگر به جای استفاده مستقیم از دیتابیس، از یک رابط (Interface) استفاده کنید، هر وقت بخواهید دیتابیس را تغییر دهید، فقط کافی است پیاده‌سازی جدیدی برای آن رابط ایجاد کنید، بدون اینکه نیاز به تغییر در کد اصلی باشد.</p>
    
    <h2>نتیجه‌گیری:</h2>
    <p>با رعایت اصول SOLID، کدهای ما تمیزتر و انعطاف‌پذیرتر می‌شوند. این اصول به ما کمک می‌کنند تا تغییرات و توسعه‌های آینده را با کمترین دردسر و بدون شکستن کدهای قبلی اعمال کنیم. این اصول در ابتدا شاید کمی پیچیده به نظر برسند، ولی وقتی در پروژه‌های بزرگ و بلندمدت استفاده شوند، به‌طور قابل‌توجهی زمان و هزینه نگهداری و توسعه را کاهش می‌دهند.</p>

    <p>برای مطالعه مقاله مرتبط دیگر درباره کدنویسی تمیز می‌توانید به <a href="https://codeplusunity.ir/blog/1/">اینجا کلیک کنید</a>.</p>

</body>